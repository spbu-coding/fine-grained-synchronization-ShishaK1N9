# Последовательная и параллельная (*с тонкой синхронизацией*) реализация двоичного дерева

Библиотека двоичных деревьев. Содержит реализацию *последовательной* и *параллельной* версии двоичного дерева поиска.

Деревья позволяют хранить пары **ключ**-**значение** и поддерживают операции поиска, вставки и удаления вершин, а также
возможность итерироваться по дереву. Параллельная версия использует алгоритмы *тонкой синхронизации* дерева.

## API

***
Оба дерева реализуют следующий интерфейс:

```Kotlin
interface ITree<KeyT : Comparable<KeyT>, ValueT> : Iterable<Pair<KeyT, ValueT>> {

    fun search(key: KeyT): ValueT?
    fun remove(key: KeyT): Boolean
    fun insert(key: KeyT, value: ValueT): Boolean
}
```

### Операция поиска

```Kotlin
fun search(key: KeyT): ValueT?
```

Принимает **ключ**. Возвращает **значение**, ассоциированное с данным ключом, либо `null`, если с ключом не
ассоциировано никакого значения.

### Операция удаления

```Kotlin
fun remove(key: KeyT): Boolean
```

Принимает **ключ**. *Удаляет* вершину с таким ключом и возвращает `true`, если такая вершина существует. Иначе *не
изменяет** структуру дерева и возвращает `false`.

### Операция вставки

```Kotlin
fun insert(key: KeyT, value: ValueT): Boolean
```

Принимает **ключ** и **значение**. *Вставляет* вершину и возвращает `true`, если ранее дерево не содержало вершину с
таким ключом. Иначе *не изменяет* структуру дерева и возвращает `false`.

## Реализация класса вершин параллельной версии

***

### Mutex вершины:

```Kotlin
var lck: ReentrantLock
```

### Блокировка и разблокировка mutex'а:

```Kotlin
fun lock()

fun unlock()
```

### Блокировка и разблокировка mutex'ов вершины и родителя:

```Kotlin
fun lockFamily()

fun unlockFamily()
```

### Блокировка mutex'ов детей:

```Kotlin
fun lockChildren()
```

### Блокировка ребенка с тонкой синхронизацией:

```Kotlin
fun moveToChild(child: ConcurrentNode<KeyT, ValueT>)
```

### Поиск самой правой вершины с тонкой синхронизацией:

```Kotlin
fun rightmostNode(): ConcurrentNode<KeyT, ValueT>
```

### Вставка вершины в поддерево с корнем в текущей вершине с тонкой синхронизацией:

```Kotlin
fun insertNode(node: ConcurrentNode<KeyT, ValueT>) 
```

## Реализация *тонкой синхронизации* в параллельной версии

Все методы реализуемого интерфейса вызывают метод:

```Kotlin
private fun findNodeOrPotentialParent(key: KeyT): ConcurrentNode<KeyT, ValueT>?
```

Он возвращает либо `null`, если дерево пустое, либо вершину, которая является вершиной с переданным ключом или
потенциальным родителем вершины с переданным ключом.

Для *тонкой синхронизации* использовался следующие алгоритмы

В методе `findNodeOrPotentialParent`:

1. Блокируется глобальный mutex.
    * Сделано, чтобы гарантировать неизменность корня дерева во время захвата его mutex'а;
    * Отпускается, либо, когда метод переходит к одному из детей корня, либо, когда в вызывающих данный метод функциях
      заканчивается работа с корнем.
2. Блокируется mutex корня дерева (корень становится текущей вершиной).
3. Блокируется mutex текущей вершины и нужного ребенка (левого, если искомый ключ меньше, правого - больше).
4. Отпускается mutex родителя текущей вершины, если вершина не корень, и самой вершины.
5. Нужный ребенок становится текущей вершиной.
6. Повторяются пункты 3-5, пока не будет найдена искомая вершина, либо же потенциальный родитель.

> Во время работы данного метода захватывается максимум **2** mutex'а.

В методе `search`

1. Вызывается `findNodeOrPotentialParent`.
    * Если получен `null`, отпускается глобальный mutex и возвращается `null`;
    * Иначе запоминается полученная вершина, и алгоритм продолжает работу с ней.
2. В переменную `value` записывается значение полученной вершины, если ее ключ совпадает с искомым ключом, иначе `null`.
3. Если полученная вершина была корнем дерева - отпускается глобальный mutex.
4. Отпускаются mutex'ы полученной вершины и ее родителя, если такой имеется.
5. Возвращается `value`.

> Во время поиска вершины захватывается максимум **2** mutex'а.

В методе `remove`:

1. Вызывается `findNodeOrPotentialParent`.
    * Если получен `null`, отпускается глобальный mutex и возвращается `false`;
    * Иначе запоминается полученная вершина, и алгоритм продолжает работу с ней.
2. Если ключ полученной вершины не совпадет с искомым:
    1. Если полученная вершина была корнем дерева - отпускается глобальный mutex.
    2. Отпускаются mutex'ы полученной вершины и ее родителя, если такой имеется.
    3. Возвращается `false`
3. Блокируются mutex'ы имеющихся детей.
4. В зависимости от количества детей полученная вершина удаляется
    * Если вершина является листом:
        1. Ссылка на вершину обнуляется.
        2. Mutex родителя, если такой есть, отпускается.
    * Если у вершины всего один ребенок:
        1. Ребенок ставится на место текущей вершины.
        2. Отпускаются mutex'ы ребенка и родителя, если такой есть.
    * Если у вершины есть оба ребенка:
        1. Левый ребенок ставится на место текущей вершины.
        2. Правый ребенок вставляется в поддерево с корнем в левом ребенке удаляемой вершины.
            * Используется тот же алгоритм перемещения, что и в методе `findNodeOrPotentialParent`.
        3. После вставки освобождаются mutex'ы вставленной вершины, вершины, которая стала родителем вставляемой
           вершины, и ее родителя, если такой есть.
5. Возвращается `true`.

> Во время удаления вершины захватывается максимум **4** mutex'а.


В методе `insert`:

1. Вызывается `findNodeOrPotentialParent`.
    * Если получен `null`:
        1. Новая вершина становится корнем дерева;
        2. Отпускается глобальный mutex и возвращается `true`;
    * Иначе запоминается полученная вершина, и алгоритм продолжает работу с ней.
2. Если полученная вершина является корнем - отпускается глобальный mutex.
3. Если ключ новой вершины совпадает с ключом полученной вершины:
    * Отпускаются mutex'ы полученной вершины и ее родителя, если такой есть;
    * Возвращается `false`.
4. Новая вершина вставляется в полученную с нужной стороны (справа - ключ новой больше ключа полученной, слева - меньше).
5. Отпускаются mutex'ы полученной вершины и ее родителя, если такой есть.
6. Возвращается `true`.

> Во время вставки вершины захватывается максимум **2** mutex'а.

## Тестирование

***

Тесты автоматически запускаются при каждом `pull-request'е` в `main`

### Последовательная версия

Для тестирования используется библиотека [JUnit 5](https://junit.org/junit5/). После прохождения тестирования с помощью
библиотеки [JaCoCo](https://www.eclemma.org/jacoco/) генерируется отчёт о покрытии кода тестами.

### Параллельная версия (*с тонкой синхронизацией*)

Для тестирования используется библиотека [JUnit 5](https://junit.org/junit5/) с
фреймворком [kotlinx-lincheck](https://github.com/Kotlin/kotlinx-lincheck).
Проводились [Stress тесты](https://github.com/Kotlin/kotlinx-lincheck#stress-testing)
и [Model Checking тесты](https://github.com/Kotlin/kotlinx-lincheck#model-checking). Так как инструмент подсчета
покрытия не обнаруживает покрытие кода тестами lincheck, было решено не генерировать отчет о покрытии.

#### Stress тесты

Так как тестирование параллельной версии чрезмерно нагружают CI из-за длительности проверки, было решено ограничиться
тремя разными тестами и запускать в CI только один тест:

* на *трех* потоках:

```Kotlin
fun stressTestOn3Threads(): Unit
```

* на *пяти* потоках (не запускается в CI):

```Kotlin
fun stressTestOn5Threads(): Unit
```

* c *пятьюстами* различных сценариев (не запускается в CI):

```Kotlin
fun stressTestWith500Scenarios(): Unit
```

#### Model тесты

Для проверки модели в качестве эталонной реализации была взята `ConcurrentHashMap`.

```Kotlin
 fun modelCheckingTest(): Unit
```
